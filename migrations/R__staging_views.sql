USE SCHEMA SCHEMA_CHANGE_TEST;

create or replace view VW_DICTIONARY_STG(
	ID,
	STUDY_ID,
	VERSION,
	STATUS_ID,
	COMMENT,
	SOURCE_PARENT_ID,
	SOURCE_ID,
	VERSION_RELEASE_DATE,
	CRT_TS,
	CRT_BY,
	UPD_BY,
	UPD_TS,
	DB_VERSIONID
) as
SELECT 
  STUDY_STG.DICTIONARY_ID AS ID, 
  STUDY_STG.STUDY_ID, 
  STUDY_STG.VERSION, 
  0 AS STATUS_ID, 
  NULL AS COMMENT, 
  STUDY_STG.SOURCE_PARENT_ID, 
  VW_SOURCE.SOURCE_ID AS SOURCE_ID, 
  STUDY_STG.VERSION_RELEASE_DATE, 
  CURRENT_TIMESTAMP AS CRT_TS, 
  VW_USER_INFO.ID AS CRT_BY, 
  VW_USER_INFO.ID AS UPD_BY, 
  CURRENT_TIMESTAMP AS UPD_TS, 
  STUDY_STG.DP_VERSION_ID AS DB_VERSIONID 
FROM 
  "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."STUDY_STG" AS STUDY_STG 
  LEFT JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_SOURCE" AS VW_SOURCE ON VW_SOURCE.SOURCE = STUDY_STG.SOURCE
  LEFT JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_USER_INFO" on VW_USER_INFO.FIRST_NAME = 'ETL_USER';
  

create or replace view VW_STUDY_STG(
	ID,
	NAME,
	STUDY_FAMILY_ID,
	STUDY_RELEASE_ID,
	STUDY_TYPE_ID,
	STUDY_CODE,
	SECURITYCODE,
	RELEASE_DATE,
	YEAR,
	TREND_FAMILY_ID,
	MINWAVE,
	MAXWAVE,
	STARTFIELDDATE,
	ENDFIELDDATE,
	USEEXTERNALKEY,
	ACTIVE,
	PARENT_STUDY_ID,
	DP_STUDYID,
	CRT_TS,
	CRT_BY,
	UPD_BY,
	UPD_TS,
	HIDE,
	DICTIONARY_ID
) as 
SELECT 
  STUDY_STG.STUDY_ID AS ID, 
  STUDY_STG.STUDY_NAME AS NAME, 
  STUDY_FAMILY.ID AS STUDY_FAMILY_ID, 
  STUDY_RELEASE.ID AS STUDY_RELEASE_ID, 
  STUDY_TYPE.ID AS STUDY_TYPE_ID, 
  STUDY_STG.STUDY_CODE, 
  STUDY_STG.SECURITY_CODE AS SECURITYCODE, 
  STUDY_STG.RELEASE_DATE, 
  STUDY_STG.YEAR, 
  TREND_FAMILY.ID AS TREND_FAMILY_ID, 
  STUDY_STG.MIN_WAVE AS MINWAVE, 
  STUDY_STG.MAX_WAVE AS MAXWAVE, 
  STUDY_STG.START_FIELD_DATE AS STARTFIELDDATE, 
  STUDY_STG.END_FIELD_DATE AS ENDFIELDDATE, 
  CASE WHEN STUDY_STG.USE_EXTERNAL_KEY = 1 THEN TRUE ELSE FALSE END AS USEEXTERNALKEY, 
  CASE WHEN STUDY_STG.ACTIVE = 1 THEN TRUE ELSE FALSE END AS ACTIVE, 
  STUDY_STG.PARENT_STUDY_ID, 
  STUDY_STG.DP_STUDY_ID AS DP_STUDYID, 
  CURRENT_TIMESTAMP AS CRT_TS, 
  VW_USER_INFO.ID AS CRT_BY, 
  VW_USER_INFO.ID AS UPD_BY, 
  CURRENT_TIMESTAMP AS UPD_TS, 
  CASE WHEN STUDY_STG.HIDE = 1 THEN TRUE ELSE FALSE END AS HIDE,
  STUDY_STG.DICTIONARY_ID
FROM 
  "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."STUDY_STG" AS STUDY_STG 
  LEFT JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_STUDY_FAMILY" AS STUDY_FAMILY ON STUDY_FAMILY.STUDY_FAMILY = STUDY_STG.STUDY_FAMILY 
  LEFT JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_STUDY_RELEASE" AS STUDY_RELEASE ON STUDY_STG.STUDY_RELEASE = STUDY_RELEASE.STUDY_RELEASE 
  LEFT JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_STUDY_TYPE" AS STUDY_TYPE ON STUDY_STG.STUDY_TYPE = STUDY_TYPE.STUDY_TYPE 
  LEFT JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_TREND_FAMILY" AS TREND_FAMILY ON STUDY_STG.TREND_FAMILY = TREND_FAMILY.TREND_FAMILY
  LEFT JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_USER_INFO" on VW_USER_INFO.FIRST_NAME = 'ETL_USER';
  
create or replace view VW_DICTIONARY_ITEM_STG(
	D_STUDY_ID,
	D_VERSION_ID,
	FULL_LABEL,
	SUPER,
	CATEGORY,
	DETAIL1,
	DETAIL2,
	DETAIL3,
	DETAIL4,
	TIMEPERIOD,
	KEYWORD,
	QLEVEL,
	DISPLAY_TYPE,
	CCP,
	EXTERNAL_KEY,
	SORT,
	MEMRI_DEFINITION,
	DATA_TYPE,
	ACCESS_CODE,
	IS_NEW,
	FIRST_WAVE,
	MIN,
	MAX
) as 
WITH DICTIONARY_ITEM AS (
  SELECT 
    D_STUDY_ID as STUDY_ID, 
    D_VERSION_ID as VERSION, 
    FULL_LABEL, 
    FLATTEN_LABEL.VALUE :: STRING AS TEXT, 
    FLATTEN_LABEL.INDEX :: STRING AS TEXT_INDEX, 
    FLATTEN_LABEL.THIS :: ARRAY AS ARR_FULL_LABEL, 
    ARRAY_SLICE(ARR_FULL_LABEL, 0, TEXT_INDEX + 1) AS FULL_ARRAY_SLICE, 
    ARRAY_SLICE(ARR_FULL_LABEL, 0, TEXT_INDEX) AS PARENT_CHAIN, 
    CASE WHEN TEXT_INDEX = 0 THEN 'c' WHEN TEXT_INDEX = ARRAY_SIZE(ARR_FULL_LABEL) -2 THEN 'q' WHEN TEXT_INDEX = 1 THEN 's' WHEN TEXT_INDEX = ARRAY_SIZE(ARR_FULL_LABEL)-1 THEN 'a' ELSE 't' END AS DICTIONARY_ITEM_TYPE, 
    CAST(QLEVEL AS INT) AS QLEVEL, 
    CASE WHEN TEXT_INDEX = QLEVEL - 1 THEN TRUE ELSE FALSE END AS IS_Q_LEVEL, 
    CASE WHEN IS_Q_LEVEL = TRUE THEN DISPLAY_TYPE ELSE 0 END AS DISPLAY_TYPE 
  FROM 
    "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."DICTIONARY_ITEM_STG" as DICTIONARY_STG, 
    LATERAL FLATTEN(
      INPUT => SPLIT(FULL_LABEL, '|')
    ) FLATTEN_LABEL
), 
PROCESSED_DISPLAY_TYPE as(
  SELECT 
    TEXT, 
    DICTIONARY_ITEM_TYPE, 
    IS_Q_LEVEL, 
    DISPLAY_TYPE, 
    ARR_FULL_LABEL, 
    FULL_ARRAY_SLICE, 
    PARENT_CHAIN, 
    FULL_LABEL 
  FROM 
    DICTIONARY_ITEM QUALIFY ROW_NUMBER() OVER (
      PARTITION BY FULL_ARRAY_SLICE
      ORDER BY 
        FULL_ARRAY_SLICE, 
        DISPLAY_TYPE DESC
    ) = 1
), 
COMBINED_DICTIONARY_ITEM as (
  select 
    DICTIONARY_ITEM.FULL_LABEL, 
    DICTIONARY_ITEM.TEXT, 
    DICTIONARY_ITEM.TEXT_INDEX, 
    DICTIONARY_ITEM.FULL_ARRAY_SLICE, 
    DICTIONARY_ITEM.DICTIONARY_ITEM_TYPE, 
    PROCESSED_DISPLAY_TYPE.DISPLAY_TYPE, 
    PROCESSED_DISPLAY_TYPE.IS_Q_LEVEL, 
    CASE WHEN PROCESSED_DISPLAY_TYPE.IS_Q_LEVEL = TRUE THEN 'X' ELSE TEXT_INDEX END AS GROUP_TEXT_INDEX 
  from 
    DICTIONARY_ITEM 
    join PROCESSED_DISPLAY_TYPE on DICTIONARY_ITEM.FULL_ARRAY_SLICE = PROCESSED_DISPLAY_TYPE.FULL_ARRAY_SLICE 
), 
NEW_TEXT as (
  SELECT 
    FULL_LABEL, 
    ARRAY_AGG(DISPLAY_TYPE) as AGGREGRATE_DISPLAY_TYPE, 
    LISTAGG(TRIM(TEXT), ' - ') WITHIN GROUP (
      ORDER BY 
        TEXT_INDEX
    ) as NEW_TEXT, 
    GET(
      ARRAY_AGG(TEXT_INDEX), 
      0
    ):: INTEGER as TEXT_INDEX, 
    CASE WHEN ARRAY_SIZE(AGGREGRATE_DISPLAY_TYPE) > 1 THEN TRUE ELSE NULL END AS ADJUST_Q_LEVEL 
  FROM 
    COMBINED_DICTIONARY_ITEM 
  group by 
    FULL_LABEL, 
    GROUP_TEXT_INDEX
), 
NEW_FULL_LABEL as (
  select 
    FULL_LABEL, 
    LISTAGG(TRIM(NEW_TEXT), '|') WITHIN GROUP (
      ORDER BY 
        TEXT_INDEX
    ) AS NEW_FULL_LABEL, 
    GET(
      ARRAY_AGG(ADJUST_Q_LEVEL), 
      0
    ):: BOOLEAN as ADJUST_Q_LEVEL 
  from 
    NEW_TEXT 
  group by 
    FULL_LABEL
) 
select 
  DICTIONARY_ITEM_STG.D_STUDY_ID, 
  DICTIONARY_ITEM_STG.D_VERSION_ID, 
  NEW_FULL_LABEL.NEW_FULL_LABEL as FULL_LABEL, 
  DICTIONARY_ITEM_STG.SUPER, 
  DICTIONARY_ITEM_STG.CATEGORY, 
  DICTIONARY_ITEM_STG.DETAIL1, 
  DICTIONARY_ITEM_STG.DETAIL2, 
  DICTIONARY_ITEM_STG.DETAIL3, 
  DICTIONARY_ITEM_STG.DETAIL4, 
  DICTIONARY_ITEM_STG.TIMEPERIOD, 
  DICTIONARY_ITEM_STG.KEYWORD, 
  CASE WHEN NEW_FULL_LABEL.ADJUST_Q_LEVEL = TRUE THEN DICTIONARY_ITEM_STG.QLEVEL - 1 ELSE DICTIONARY_ITEM_STG.QLEVEL END AS QLEVEL,
  DICTIONARY_ITEM_STG.DISPLAY_TYPE, 
  DICTIONARY_ITEM_STG.CCP, 
  DICTIONARY_ITEM_STG.EXTERNAL_KEY, 
  DICTIONARY_ITEM_STG.SORT, 
  DICTIONARY_ITEM_STG.MEMRI_DEFINITION, 
  DICTIONARY_ITEM_STG.DATA_TYPE, 
  DICTIONARY_ITEM_STG.ACCESS_CODE, 
  DICTIONARY_ITEM_STG.IS_NEW, 
  DICTIONARY_ITEM_STG.FIRST_WAVE, 
  DICTIONARY_ITEM_STG.MIN, 
  DICTIONARY_ITEM_STG.MAX
from 
  NEW_FULL_LABEL 
  join "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."DICTIONARY_ITEM_STG" on NEW_FULL_LABEL.FULL_LABEL = DICTIONARY_ITEM_STG.FULL_LABEL;


create or replace view VW_ITEM_TEXT(
	TEXT_ID,
	TEXT
) as

--GET THE ITEM_TEXT OF BOTH, INSIGHT  AND MEMRI, FOR A GIVEN DICTIONARY
WITH DICTIONARY_ITEM_TEXT AS (
  SELECT
    FLATTEN_LABEL.VALUE :: STRING AS TEXT
  FROM
    "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE".VW_DICTIONARY_ITEM_STG,
    LATERAL FLATTEN(
      INPUT => SPLIT(FULL_LABEL, '|')
    ) FLATTEN_LABEL
  UNION
  SELECT
    TEXT_INFO.TEXT AS TEXT
  FROM
    "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE".VW_DICTIONARY_ITEM_STG UNPIVOT(
      TEXT FOR LEVEL IN (
        SUPER, CATEGORY, DETAIL1, DETAIL2,
        DETAIL3, DETAIL4, TIMEPERIOD
      )
    ) AS TEXT_INFO
),
-- GET TEXT_ID FOR ITEM_TEXT FROM 'ITEM_TEXT' TABLE
ID_OF_ITEM_TEXT AS (
  SELECT
    DISTINCT ITEM_TEXT.ID,
    DICTIONARY_ITEM_TEXT.TEXT
  FROM
    DICTIONARY_ITEM_TEXT
    LEFT JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY".ITEM_TEXT AS ITEM_TEXT ON DICTIONARY_ITEM_TEXT.TEXT = ITEM_TEXT.TEXT
),
-- GET ID OF ITEM_TEXT WHOSE ID IS NULL BY IGNORING CASE(LOWER AND UPPER CASE).
ID_OF_ITEM_TEXT_IGNORING_CASE AS (
  SELECT
    DISTINCT ITEM_TEXT.ID,
    ID_OF_ITEM_TEXT.TEXT
  FROM
    ID_OF_ITEM_TEXT
    LEFT JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY".ITEM_TEXT AS ITEM_TEXT ON UPPER(ID_OF_ITEM_TEXT.TEXT) = UPPER(ITEM_TEXT.TEXT)
  WHERE
    ID_OF_ITEM_TEXT.ID IS NULL
),
-- GET ID OF ITEM_TEXT WHOSE ID IS NULL from ID_OF_ITEM_TEXT_IGNORING_CASE CTE BY USING REGEX.
ID_OF_ITEM_TEXT_USING_REGEX AS (
  SELECT
    DISTINCT ITEM_TEXT.ID,
    ID_OF_ITEM_TEXT_IGNORING_CASE.TEXT
  FROM
    ID_OF_ITEM_TEXT_IGNORING_CASE
    LEFT JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY".ITEM_TEXT AS ITEM_TEXT ON LOWER(
      REGEXP_REPLACE(
        ID_OF_ITEM_TEXT_IGNORING_CASE.TEXT,
        '[" ",\n]', ''
      )
    ) = LOWER(
      REGEXP_REPLACE(ITEM_TEXT.TEXT, '[" ",\n]', '')
    )
  WHERE
    ID_OF_ITEM_TEXT_IGNORING_CASE.ID IS NULL
),
FINAL_DATA AS (
  SELECT
    *
  FROM
    ID_OF_ITEM_TEXT
  UNION
  SELECT
    *
  FROM
    ID_OF_ITEM_TEXT_IGNORING_CASE
  UNION
  SELECT
    *
  FROM
    ID_OF_ITEM_TEXT_USING_REGEX
)
SELECT
  distinct *
FROM
  FINAL_DATA;
  
  
create or replace view VW_INSIGHT_DICTIONARY_ITEM(
	DICTIONARY_ID,
	STUDY_ID,
	DICTIONARY_ITEM_ID,
	DP_STUDY_ID,
	VERSION,
	TYPE_ID,
	DICTIONARY_ITEM_TYPE,
	TEXT_ID,
	TEXT,
	KEYWORD,
	PARENT_ID,
	IS_Q_LEVEL,
	DISPLAY_TYPE,
	CCP,
	EXTERNAL_KEY,
	PERSISTENT_ID,
	MEMRI_DEFINITION,
	DATA_TYPE,
	DATA_TYPE_ID,
	ACTIVE,
	MIN,
	MAX,
	SORT,
	ACCESS_CODE,
	IS_NEW,
	FIRST_WAVE,
	DELIVERABLE_ID,
	CRT_TS,
	CRT_BY,
	UPD_BY,
	UPD_TS,
	FULL_ARRAY_SLICE,
	SORT_ARRAY_SLICE,
	PARENT_CHAIN,
	DICTIONARY_ITEM_SORT,
	FULL_LABEL
) as (
  
WITH TEMP_DICTIONARY AS (
  SELECT 
    D_STUDY_ID as STUDY_ID, 
    D_VERSION_ID as VERSION, 
    FULL_LABEL, 
    FLATTEN_LABEL.VALUE :: STRING AS TEXT, 
    FLATTEN_LABEL.INDEX :: STRING AS TEXT_INDEX, 
    FLATTEN_LABEL.THIS :: ARRAY AS ARR_FULL_LABEL, 
    ARRAY_SLICE(ARR_FULL_LABEL, 0, TEXT_INDEX + 1) AS FULL_ARRAY_SLICE, 
    ARRAY_SLICE(ARR_FULL_LABEL, 0, TEXT_INDEX) AS PARENT_CHAIN, 
    CASE WHEN TEXT_INDEX = 0 THEN 'c' WHEN TEXT_INDEX = ARRAY_SIZE(ARR_FULL_LABEL) -2 THEN 'q' WHEN TEXT_INDEX = 1 THEN 's' WHEN TEXT_INDEX = ARRAY_SIZE(ARR_FULL_LABEL)-1 THEN 'a' ELSE 't' END AS DICTIONARY_ITEM_TYPE, 
    CASE WHEN DICTIONARY_ITEM_TYPE = 'a' THEN KEYWORD ELSE TEXT END AS KEYWORD, 
    CAST(QLEVEL AS INT) AS QLEVEL, 
    CASE WHEN TEXT_INDEX = QLEVEL - 1 THEN TRUE ELSE FALSE END AS IS_Q_LEVEL, 
    CASE WHEN IS_Q_LEVEL = TRUE THEN DISPLAY_TYPE ELSE 0 END AS DISPLAY_TYPE, 
    CASE WHEN DICTIONARY_ITEM_TYPE = 'a' THEN CCP ELSE NULL END AS CCP, 
    CASE WHEN DICTIONARY_ITEM_TYPE = 'a' THEN EXTERNAL_KEY ELSE NULL END AS EXTERNAL_KEY, 
    CASE WHEN DICTIONARY_ITEM_TYPE = 'a' THEN MIN ELSE NULL END AS MIN, 
    CASE WHEN DICTIONARY_ITEM_TYPE = 'a' THEN MAX ELSE NULL END AS MAX, 
    CASE WHEN DICTIONARY_ITEM_TYPE = 'a' THEN ARRAY_SLICE(ARR_FULL_LABEL, 0, TEXT_INDEX) ELSE ARRAY_SLICE(ARR_FULL_LABEL, 0, TEXT_INDEX + 1) END AS SORT_ARRAY_SLICE, 
    CASE WHEN DICTIONARY_ITEM_TYPE = 'a' THEN SORT ELSE NULL END AS SORT, 
    CASE WHEN DICTIONARY_ITEM_TYPE = 'a' THEN MEMRI_DEFINITION ELSE NULL END AS MEMRI_DEFINITION, 
    CASE WHEN DICTIONARY_ITEM_TYPE = 'a' THEN DATA_TYPE ELSE NULL END AS DATA_TYPE, 
    IS_NEW, 
    FIRST_WAVE, 
    LAG(text) over(
      partition by FULL_LABEL 
      ORDER BY 
        TEXT_INDEX
    ) as parent_text, 
    LAG(TEXT_INDEX) over(
      partition by FULL_LABEL 
      ORDER BY 
        TEXT_INDEX
    ) as PARENT_TEXT_INDEX, 
    LAG(DICTIONARY_ITEM_TYPE) over(
      partition by FULL_LABEL 
      ORDER BY 
        TEXT_INDEX
    ) as PARENT_DICTIONARY_ITEM_TYPE,
    FLATTEN_LABEL.*,
    'ETL_USER' as USERNAME
    
  FROM 
    "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."VW_DICTIONARY_ITEM_STG"
 as DICTIONARY_STG, 
    LATERAL FLATTEN(
      INPUT => SPLIT(FULL_LABEL, '|')
    ) FLATTEN_LABEL
),
  
ACCESS_CODE as (
  
 SELECT 
  FULL_ARRAY_SLICE, 
  ARRAY_AGG(DISTINCT ACCESS_CODE) AS ALL_ACCESS_CODES, 
  ARRAY_TO_STRING(ALL_ACCESS_CODES, '|') ACCESS_CODE, 
  ARRAY_SIZE(ALL_ACCESS_CODES) AS LENGTH 
FROM 
  (
    SELECT 
      FULL_LABEL, 
      ACCESS_CODE, 
      INDEX AS TEXT_INDEX, 
      VALUE :: STRING AS TEXT, 
      THIS AS ARR_FULL_LABEL, 
      ARRAY_SLICE(ARR_FULL_LABEL, 0, TEXT_INDEX + 1) AS FULL_ARRAY_SLICE 
    FROM 
      "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."VW_DICTIONARY_ITEM_STG", 
      LATERAL FLATTEN(
        INPUT => SPLIT(FULL_LABEL, '|')
      ) FLATTEN_LABEL
  ) 
GROUP BY 
  FULL_ARRAY_SLICE 
HAVING 
  LENGTH = 1 
ORDER BY 
  FULL_ARRAY_SLICE
),


PROCESSED_DICTIONARY AS (
  SELECT 
    "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."SEQ_DICTIONARY_ITEM".NEXTVAL AS DICTIONARY_ITEM_ID, 
    * 
  FROM 
    (
      SELECT 
        STUDY_ID, 
        VERSION, 
        TEXT_INDEX, 
        DICTIONARY_ITEM_TYPE, 
        TEXT, 
        KEYWORD, 
        IS_Q_LEVEL, 
        DISPLAY_TYPE, 
        CCP, 
        EXTERNAL_KEY, 
        MEMRI_DEFINITION, 
        DATA_TYPE, 
        MIN, 
        MAX, 
        SORT, 
        IS_NEW,
        ARR_FULL_LABEL,
        FULL_ARRAY_SLICE, 
        SORT_ARRAY_SLICE, 
        PARENT_CHAIN, 
        FIRST_WAVE, 
        PARENT_TEXT, 
        PARENT_TEXT_INDEX, 
        PARENT_DICTIONARY_ITEM_TYPE,
        USERNAME,
        FULL_LABEL
      FROM 
        TEMP_DICTIONARY QUALIFY ROW_NUMBER() OVER (
          PARTITION BY FULL_ARRAY_SLICE, 
          DICTIONARY_ITEM_TYPE, 
          TEXT_INDEX 
          ORDER BY 
            FULL_ARRAY_SLICE,
            DISPLAY_TYPE DESC
        ) = 1
    )
)

SELECT 
  DICTIONARY.ID as DICTIONARY_ID, 
  STUDY.ID as STUDY_ID, 
  DICTIONARY_ITEM_ID, 
  PROCESSED_DICTIONARY.STUDY_ID as DP_STUDY_ID, 
  PROCESSED_DICTIONARY.VERSION, 
  VW_DICTIONARY_ITEM_TYPE.ID as TYPE_ID, 
  PROCESSED_DICTIONARY.DICTIONARY_ITEM_TYPE, 
  TEXT_ID, 
  PROCESSED_DICTIONARY.TEXT, 
  CASE WHEN PROCESSED_DICTIONARY.DICTIONARY_ITEM_TYPE = 'a' THEN KEYWORD ELSE 'h' || TEXT_ID END AS KEYWORD, 
  PARENT.PARENT_ID, 
  IS_Q_LEVEL, 
  DISPLAY_TYPE, 
  CCP, 
  EXTERNAL_KEY, 
  NULL as PERSISTENT_ID,
  NULL as MEMRI_DEFINITION, 
  PROCESSED_DICTIONARY.DATA_TYPE, 
  VW_DATA_TYPE.DATA_TYPE_ID,
  TRUE as ACTIVE, 
  MIN, 
  MAX, 
  CASE WHEN PROCESSED_DICTIONARY.DICTIONARY_ITEM_TYPE = 'a' THEN SORT ELSE NULL END AS SORT, 
  ACCESS_CODE, 
  CASE WHEN PROCESSED_DICTIONARY.DICTIONARY_ITEM_TYPE = 'a' THEN IS_NEW ELSE NULL END AS IS_NEW, 
  CASE WHEN PROCESSED_DICTIONARY.DICTIONARY_ITEM_TYPE = 'a' THEN FIRST_WAVE ELSE NULL END AS FIRST_WAVE,
  VW_DICTIONARY_ITEM_TYPE.DELIVERABLE_ID, 
  CURRENT_TIMESTAMP AS CRT_TS, 
  VW_USER_INFO.ID AS CRT_BY, 
  NULL AS UPD_BY, 
  NULL AS UPD_TS, 
  PROCESSED_DICTIONARY.FULL_ARRAY_SLICE, 
  PROCESSED_DICTIONARY.SORT_ARRAY_SLICE,
  PROCESSED_DICTIONARY.PARENT_CHAIN, 
  ROW_NUMBER() OVER (
    ORDER BY 
      SORT_ARRAY_SLICE, 
      PARENT_CHAIN, 
      SORT
  ) as DICTIONARY_ITEM_SORT,
  PROCESSED_DICTIONARY.FULL_LABEL
FROM 
  PROCESSED_DICTIONARY 
  LEFT JOIN (
    SELECT 
      FULL_ARRAY_SLICE, 
      DICTIONARY_ITEM_ID AS PARENT_ID, 
      TEXT_INDEX, 
      DICTIONARY_ITEM_TYPE 
    FROM 
      PROCESSED_DICTIONARY 
  ) AS PARENT ON PARENT.FULL_ARRAY_SLICE = PROCESSED_DICTIONARY.PARENT_CHAIN 
  and PARENT.TEXT_INDEX = PROCESSED_DICTIONARY.PARENT_TEXT_INDEX 
  and PARENT.DICTIONARY_ITEM_TYPE = PROCESSED_DICTIONARY.PARENT_DICTIONARY_ITEM_TYPE 
  LEFT JOIN (
    SELECT 
      * 
    FROM 
      "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."VW_ITEM_TEXT" QUALIFY ROW_NUMBER() OVER (
        PARTITION BY TEXT 
        ORDER BY 
          TEXT_ID ASC
      ) = 1
  ) as ITEM_TEXT ON ITEM_TEXT.TEXT = PROCESSED_DICTIONARY.TEXT 
  LEFT JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_DICTIONARY_ITEM_TYPE" ON VW_DICTIONARY_ITEM_TYPE.TYPE = PROCESSED_DICTIONARY.DICTIONARY_ITEM_TYPE 
  LEFT JOIN "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."VW_STUDY_STG" as STUDY ON STUDY.DP_STUDYID = PROCESSED_DICTIONARY.STUDY_ID 
  LEFT JOIN "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."VW_DICTIONARY_STG" as DICTIONARY on DICTIONARY.STUDY_ID = STUDY.ID
  and DICTIONARY.DB_VERSIONID = PROCESSED_DICTIONARY.VERSION 
  LEFT JOIN ACCESS_CODE on PROCESSED_DICTIONARY.FULL_ARRAY_SLICE = ACCESS_CODE.FULL_ARRAY_SLICE
  LEFT JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_USER_INFO" on VW_USER_INFO.FIRST_NAME = PROCESSED_DICTIONARY.USERNAME
  LEFT JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_DATA_TYPE" on LOWER(PROCESSED_DICTIONARY.DATA_TYPE) = LOWER(VW_DATA_TYPE.DATA_TYPE)
ORDER BY
   DICTIONARY_ITEM_SORT
);


create or replace view VW_MEMRI_DICTIONARY_ITEM(
	DICTIONARY_ID,
	STUDY_ID,
	DICTIONARY_ITEM_ID,
	DP_STUDY_ID,
	VERSION,
	TYPE_ID,
	DICTIONARY_ITEM_TYPE,
	TEXT_ID,
	TEXT,
	KEYWORD,
	PARENT_ID,
	IS_Q_LEVEL,
	DISPLAY_TYPE,
	CCP,
	EXTERNAL_KEY,
	PERSISTENT_ID,
	MEMRI_DEFINITION,
	DATA_TYPE,
	DATA_TYPE_ID,
	ACTIVE,
	MIN,
	MAX,
	SORT,
	ACCESS_CODE,
	IS_NEW,
	FIRST_WAVE,
	DELIVERABLE_ID,
	CRT_TS,
	CRT_BY,
	UPD_BY,
	UPD_TS,
	LEAF_LEVEL,
	FULL_ARRAY_SLICE,
	DICTIONARY_ITEM_SORT,
	FULL_LABEL
) as (
WITH UNPIVOTED_DICTIONARY_ITEM AS (
  SELECT 
    D_STUDY_ID AS STUDY_ID, 
    D_VERSION_ID AS VERSION, 
    TEXT_INFO.LEVEL AS DICTIONARY_ITEM_TYPE, 
    TEXT_INFO.TEXT AS TEXT, 
    KEYWORD, 
    QLEVEL, 
    DISPLAY_TYPE, 
    CCP, 
    EXTERNAL_KEY, 
    SORT, 
    MEMRI_DEFINITION, 
    DATA_TYPE, 
    IS_NEW, 
    FIRST_WAVE, 
    FULL_LABEL, 
    ACCESS_CODE, 
    MIN, 
    MAX, 
    'ETL_USER' as USERNAME 
  FROM 
    "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."VW_DICTIONARY_ITEM_STG" UNPIVOT(
      TEXT FOR LEVEL IN (
        SUPER, CATEGORY, DETAIL1, DETAIL2, 
        DETAIL3, DETAIL4, TIMEPERIOD
      )
    ) AS TEXT_INFO 
  ORDER BY 
    KEYWORD
), 
MEMRI_LEVEL AS (
  SELECT 
    FULL_LABEL, 
    ARRAY_AGG(DICTIONARY_ITEM_TYPE) WITHIN GROUP(
      ORDER BY 
        CASE WHEN DICTIONARY_ITEM_TYPE = 'SUPER' THEN '1' WHEN DICTIONARY_ITEM_TYPE = 'CATEGORY' THEN '2' WHEN DICTIONARY_ITEM_TYPE = 'TIMEPERIOD' THEN '3' WHEN DICTIONARY_ITEM_TYPE = 'DETAIL1' THEN '4' WHEN DICTIONARY_ITEM_TYPE = 'DETAIL2' THEN '5' WHEN DICTIONARY_ITEM_TYPE = 'DETAIL3' THEN '6' WHEN DICTIONARY_ITEM_TYPE = 'DETAIL4' THEN '7' ELSE DICTIONARY_ITEM_TYPE END ASC
    ) AS MEMRI_LEVEL 
  FROM 
    UNPIVOTED_DICTIONARY_ITEM 
  GROUP BY 
    FULL_LABEL
), 
MEMRI_LEVEL_TEXT AS (
  SELECT 
    FULL_LABEL, 
    ARRAY_AGG(TEXT) WITHIN GROUP(
      ORDER BY 
        CASE WHEN DICTIONARY_ITEM_TYPE = 'SUPER' THEN '1' WHEN DICTIONARY_ITEM_TYPE = 'CATEGORY' THEN '2' WHEN DICTIONARY_ITEM_TYPE = 'TIMEPERIOD' THEN '3' WHEN DICTIONARY_ITEM_TYPE = 'DETAIL1' THEN '4' WHEN DICTIONARY_ITEM_TYPE = 'DETAIL2' THEN '5' WHEN DICTIONARY_ITEM_TYPE = 'DETAIL3' THEN '6' WHEN DICTIONARY_ITEM_TYPE = 'DETAIL4' THEN '7' ELSE DICTIONARY_ITEM_TYPE END ASC
    ) AS MEMRI_TEXT_LEVEL 
  FROM 
    UNPIVOTED_DICTIONARY_ITEM 
  GROUP BY 
    FULL_LABEL
), 
TEMP_MEMRI as (
  SELECT 
    STUDY_ID, 
    VERSION, 
    UNPIVOTED_DICTIONARY_ITEM.KEYWORD, 
    QLEVEL, 
    DISPLAY_TYPE, 
    CCP, 
    EXTERNAL_KEY, 
    SORT, 
    MEMRI_DEFINITION, 
    DATA_TYPE, 
    IS_NEW, 
    FIRST_WAVE, 
    MIN, 
    MAX, 
    MEMRI_LEVEL, 
    ACCESS_CODE, 
    MEMRI_TEXT_LEVEL, 
    USERNAME, 
    UNPIVOTED_DICTIONARY_ITEM.FULL_LABEL 
  FROM 
    UNPIVOTED_DICTIONARY_ITEM 
    JOIN MEMRI_LEVEL ON UNPIVOTED_DICTIONARY_ITEM.FULL_LABEL = MEMRI_LEVEL.FULL_LABEL 
    JOIN MEMRI_LEVEL_TEXT ON UNPIVOTED_DICTIONARY_ITEM.FULL_LABEL = MEMRI_LEVEL_TEXT.FULL_LABEL QUALIFY ROW_NUMBER() OVER (
      PARTITION BY MEMRI_LEVEL.FULL_LABEL 
      ORDER BY 
        MEMRI_TEXT_LEVEL
    ) = 1
)
, 
ACCESS_CODE as(
  SELECT 
    FULL_ARRAY_SLICE, 
    ARRAY_AGG(DISTINCT ACCESS_CODE) AS ALL_ACCESS_CODES, 
    ARRAY_TO_STRING(ALL_ACCESS_CODES, '|') ACCESS_CODE, 
    ARRAY_SIZE(ALL_ACCESS_CODES) AS LENGTH 
  from 
    (
      select 
        ACCESS_CODE, 
        ARRAY_SLICE(MEMRI_TEXT_LEVEL, 0, INDEX + 1) as FULL_ARRAY_SLICE 
      from 
        TEMP_MEMRI, 
        LATERAL FLATTEN(INPUT => MEMRI_TEXT_LEVEL)
    ) 
  GROUP BY 
    FULL_ARRAY_SLICE 
  HAVING 
    LENGTH = 1 
  ORDER BY 
    FULL_ARRAY_SLICE
), 
FLATTENED_MEMRI as (
  select 
    STUDY_ID, 
    VERSION, 
    KEYWORD, 
    QLEVEL, 
    DISPLAY_TYPE, 
    EXTERNAL_KEY, 
    SORT, 
    MEMRI_DEFINITION, 
    DATA_TYPE, 
    IS_NEW, 
    FIRST_WAVE, 
    MIN, 
    MAX, 
    MEMRI_LEVEL, 
    ACCESS_CODE, 
    MEMRI_TEXT_LEVEL, 
    USERNAME, 
    FULL_LABEL, 
    SEQ, 
    KEY, 
    PATH, 
    INDEX, 
    VALUE, 
    THIS, 
    FLATTEN_LABEL.INDEX as TEXT_INDEX, 
    GET(MEMRI_LEVEL, TEXT_INDEX) :: STRING as DICTIONARY_ITEM_TYPE, 
    FLATTEN_LABEL.VALUE :: STRING as TEXT, 
    ARRAY_SLICE(
      MEMRI_TEXT_LEVEL, 0, TEXT_INDEX + 1
    ) as FULL_ARRAY_SLICE, 
    ARRAY_SLICE(MEMRI_TEXT_LEVEL, 0, TEXT_INDEX) AS PARENT_CHAIN, 
    ARRAY_SIZE(MEMRI_LEVEL) = TEXT_INDEX + 1 as LEAF_LEVEL, 
    CASE WHEN LEAF_LEVEL = TRUE THEN CCP ELSE NULL END AS CCP, 
    CASE WHEN LEAF_LEVEL = TRUE THEN ARRAY_SLICE(MEMRI_TEXT_LEVEL, 0, TEXT_INDEX) ELSE ARRAY_SLICE(
      MEMRI_TEXT_LEVEL, 0, TEXT_INDEX + 1
    ) END AS SORT_ARRAY_SLICE, 
    LAG(text) over(
      partition by MEMRI_TEXT_LEVEL 
      ORDER BY 
        FULL_LABEL,
        TEXT_INDEX
    ) as parent_text, 
    LAG(TEXT_INDEX) over(
      partition by MEMRI_TEXT_LEVEL 
      ORDER BY 
        FULL_LABEL,
        TEXT_INDEX
    ) as PARENT_TEXT_INDEX, 
    LAG(DICTIONARY_ITEM_TYPE) over(
      partition by MEMRI_TEXT_LEVEL 
      ORDER BY 
        FULL_LABEL,
        TEXT_INDEX
    ) as PARENT_DICTIONARY_ITEM_TYPE 
  from 
    TEMP_MEMRI, 
    LATERAL FLATTEN(INPUT => MEMRI_TEXT_LEVEL) FLATTEN_LABEL
)
, 
PROCESSED_MEMRI as (
  select 
    "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."SEQ_DICTIONARY_ITEM".NEXTVAL AS DICTIONARY_ITEM_ID, 
    * 
  from 
    (
      select 
        * 
      from 
        FLATTENED_MEMRI QUALIFY ROW_NUMBER() OVER (
          PARTITION BY FULL_ARRAY_SLICE, 
          DICTIONARY_ITEM_TYPE,
          TEXT_INDEX,
          CCP
          ORDER BY 
            SORT_ARRAY_SLICE, 
            PARENT_CHAIN, 
            SORT
        ) = 1 
      order by 
        SORT_ARRAY_SLICE, 
        PARENT_CHAIN, 
        SORT
    )
) 
select 
  DICTIONARY.ID as DICTIONARY_ID, 
  STUDY.ID as STUDY_ID, 
  DICTIONARY_ITEM_ID, 
  PROCESSED_MEMRI.STUDY_ID as DP_STUDY_ID, 
  PROCESSED_MEMRI.VERSION, 
  VW_DICTIONARY_ITEM_TYPE.ID as TYPE_ID, 
  PROCESSED_MEMRI.DICTIONARY_ITEM_TYPE, 
  TEXT_ID, 
  PROCESSED_MEMRI.TEXT, 
  CASE WHEN LEAF_LEVEL = TRUE THEN KEYWORD ELSE 'h' || TEXT_ID END AS KEYWORD, 
  PARENT.PARENT_ID, 
  FALSE AS IS_Q_LEVEL, 
  0 as DISPLAY_TYPE, 
  CCP, 
  CASE WHEN LEAF_LEVEL = TRUE THEN EXTERNAL_KEY ELSE NULL END AS EXTERNAL_KEY, 
  NULL as PERSISTENT_ID, 
  CASE WHEN LEAF_LEVEL = TRUE THEN MEMRI_DEFINITION ELSE NULL END AS MEMRI_DEFINITION, 
  PROCESSED_MEMRI.DATA_TYPE, 
  VW_DATA_TYPE.DATA_TYPE_ID, 
  TRUE as ACTIVE, 
  CASE WHEN LEAF_LEVEL = TRUE THEN MIN ELSE NULL END AS MIN, 
  CASE WHEN LEAF_LEVEL = TRUE THEN MAX ELSE NULL END AS MAX, 
  CASE WHEN LEAF_LEVEL = TRUE THEN SORT ELSE NULL END AS SORT, 
  ACCESS_CODE.ACCESS_CODE, 
  CASE WHEN LEAF_LEVEL = TRUE THEN IS_NEW ELSE NULL END AS IS_NEW, 
  CASE WHEN LEAF_LEVEL = TRUE THEN FIRST_WAVE ELSE NULL END AS FIRST_WAVE, 
  VW_DICTIONARY_ITEM_TYPE.DELIVERABLE_ID, 
  CURRENT_TIMESTAMP AS CRT_TS, 
  VW_USER_INFO.ID AS CRT_BY, 
  NULL AS UPD_BY, 
  NULL AS UPD_TS, 
  LEAF_LEVEL, 
  PROCESSED_MEMRI.FULL_ARRAY_SLICE, 
  ROW_NUMBER() OVER (
    ORDER BY 
      SORT_ARRAY_SLICE, 
      PARENT_CHAIN, 
      SORT
  ) as DICTIONARY_ITEM_SORT, 
  PROCESSED_MEMRI.FULL_LABEL 
from 
  PROCESSED_MEMRI 
  LEFT JOIN (
    SELECT 
      FULL_ARRAY_SLICE, 
      DICTIONARY_ITEM_ID AS PARENT_ID, 
      TEXT_INDEX, 
      DICTIONARY_ITEM_TYPE 
    FROM 
      PROCESSED_MEMRI
  ) AS PARENT ON PARENT.FULL_ARRAY_SLICE = PROCESSED_MEMRI.PARENT_CHAIN 
  and PARENT.TEXT_INDEX = PROCESSED_MEMRI.PARENT_TEXT_INDEX 
  and PARENT.DICTIONARY_ITEM_TYPE = PROCESSED_MEMRI.PARENT_DICTIONARY_ITEM_TYPE 
  LEFT JOIN (
    SELECT 
      * 
    FROM 
      "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."VW_ITEM_TEXT" QUALIFY ROW_NUMBER() OVER (
        PARTITION BY TEXT 
        ORDER BY 
          TEXT_ID ASC
      ) = 1
  ) as ITEM_TEXT ON ITEM_TEXT.TEXT = PROCESSED_MEMRI.TEXT 
  LEFT JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_DICTIONARY_ITEM_TYPE" ON LOWER(VW_DICTIONARY_ITEM_TYPE.TYPE) = LOWER(
    PROCESSED_MEMRI.DICTIONARY_ITEM_TYPE
  ) 
  LEFT JOIN "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."VW_STUDY_STG" as STUDY ON STUDY.DP_STUDYID = PROCESSED_MEMRI.STUDY_ID 
  LEFT JOIN "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."VW_DICTIONARY_STG" as DICTIONARY on DICTIONARY.STUDY_ID = STUDY.ID 
  and DICTIONARY.DB_VERSIONID = PROCESSED_MEMRI.VERSION 
  LEFT JOIN ACCESS_CODE on PROCESSED_MEMRI.FULL_ARRAY_SLICE = ACCESS_CODE.FULL_ARRAY_SLICE 
  LEFT JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_USER_INFO" on VW_USER_INFO.FIRST_NAME = PROCESSED_MEMRI.USERNAME 
  LEFT JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_DATA_TYPE" on LOWER(PROCESSED_MEMRI.DATA_TYPE) = LOWER(VW_DATA_TYPE.DATA_TYPE) 
order by 
  DICTIONARY_ITEM_SORT
);


create or replace view VW_ATTRIBUTE(
	NAME,
	CRT_TS,
	CRT_BY,
	UPD_BY,
	UPD_TS
) as 


WITH NEW_ATTRIBUTE as (
  SELECT 
    UPPER(ATTRIBUTE) as ATTRIBUTE
  FROM 
    "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."ATTRIBUTE_STG" QUALIFY ROW_NUMBER() OVER (
      PARTITION BY ATTRIBUTE
      ORDER BY 
        ATTRIBUTE
    ) = 1 
  EXCEPT 
  SELECT 
    UPPER(NAME) as NAME
  FROM 
    "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_ATTRIBUTE" QUALIFY ROW_NUMBER() OVER (
      PARTITION BY NAME
      ORDER BY 
        NAME
    ) = 1

)

SELECT 
  ATTRIBUTE as NAME,
  CURRENT_TIMESTAMP AS CRT_TS, 
  VW_USER_INFO.ID AS CRT_BY, 
  NULL AS UPD_BY, 
  NULL AS UPD_TS 
FROM 
  NEW_ATTRIBUTE
  JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_USER_INFO" ON VW_USER_INFO.FIRST_NAME = 'ETL_USER';
  
  create or replace view VW_ATTRIBUTE_MASTER(
	ATTRIBUTE_TYPE_ID,
	ATTRIBUTE_VALUE,
	ATTRIBUTE_KEY,
	ACTIVE,
	CRT_TS,
	CRT_BY,
	UPD_BY,
	UPD_TS,
	ATTRIBUTE_ID
) as 

WITH UNIQUE_ATTRIBUTE as (
  select 
    ATTRIBUTE_TYPE, 
    ATTRIBUTE, 
    ATTRIBUTE_VALUE, 
    ATTRIBUTE_KEY 
  from 
    "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."ATTRIBUTE_STG" QUALIFY ROW_NUMBER() OVER (
      PARTITION BY ATTRIBUTE_TYPE, 
      ATTRIBUTE, 
      ATTRIBUTE_VALUE 
      ORDER BY 
        ATTRIBUTE_TYPE, 
        ATTRIBUTE, 
        ATTRIBUTE_VALUE
    ) = 1
), 
NEW_ATTRIBUTE as (
  select 
    VW_ATTRIBUTE.ID as ATTRIBUTE_ID, 
    ATTRIBUTE_TYPE_ID, 
    ATTRIBUTE_VALUE, 
    ATTRIBUTE_KEY 
  from 
    UNIQUE_ATTRIBUTE 
    join "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_ATTRIBUTE_TYPE" on VW_ATTRIBUTE_TYPE.ATTRIBUTE_TYPE = UPPER(
      UNIQUE_ATTRIBUTE.ATTRIBUTE_TYPE
    ) 
    join "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_ATTRIBUTE" on VW_ATTRIBUTE.NAME = UNIQUE_ATTRIBUTE.ATTRIBUTE 
  except 
  select 
    ATTRIBUTE_ID, 
    ATTRIBUTE_TYPE_ID, 
    ATTRIBUTE_VALUE, 
    ATTRIBUTE_KEY 
  from 
    DEV_DATAMART_DB.DEV_DICTIONARY.ATTRIBUTE_MASTER
) 
select 
  ATTRIBUTE_TYPE_ID, 
  ATTRIBUTE_VALUE, 
  ATTRIBUTE_KEY, 
  TRUE as ACTIVE, 
  CURRENT_TIMESTAMP AS CRT_TS, 
  VW_USER_INFO.ID as CRT_BY, 
  NULL as UPD_BY, 
  NULL as UPD_TS, 
  ATTRIBUTE_ID 
from 
  NEW_ATTRIBUTE 
  join "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_USER_INFO" on VW_USER_INFO.FIRST_NAME = 'ETL_USER';
  
create or replace view VW_ATTRIBUTE_TYPE(
	ATTRIBUTE_TYPE,
	CRT_TS,
	CRT_BY,
	UPD_BY,
	UPD_TS
) as 

WITH NEW_ATTRIBUTE_TYPE as (
  SELECT 
    UPPER(ATTRIBUTE_TYPE) as ATTRIBUTE_TYPE
  FROM 
    "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."ATTRIBUTE_STG" QUALIFY ROW_NUMBER() OVER (
      PARTITION BY ATTRIBUTE_TYPE 
      ORDER BY 
        ATTRIBUTE_TYPE
    ) = 1 
  EXCEPT 
  SELECT 
    ATTRIBUTE_TYPE 
  FROM 
    "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_ATTRIBUTE_TYPE" QUALIFY ROW_NUMBER() OVER (
      PARTITION BY ATTRIBUTE_TYPE 
      ORDER BY 
        ATTRIBUTE_TYPE
    ) = 1
)

SELECT 
  ATTRIBUTE_TYPE,
  CURRENT_TIMESTAMP AS CRT_TS, 
  VW_USER_INFO.ID AS CRT_BY, 
  NULL AS UPD_BY, 
  NULL AS UPD_TS 
FROM 
  NEW_ATTRIBUTE_TYPE
  JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_USER_INFO" ON VW_USER_INFO.FIRST_NAME = 'ETL_USER';
  

create or replace view VW_DICTIONARY_ATTRIBUTE(
	DICTIONARY_ID,
	DICTIONARY_ITEM_ID,
	STUDY_FAMILY_ID,
	ATTRIBUTE_MASTER_ID,
	PERSISTENT_ID,
	ACTIVE,
	CRT_TS,
	CRT_BY,
	UPD_BY,
	UPD_TS,
	IS_STUDYATTRIBUTE
) as 

WITH RECURSIVE DICTIONARY_ITEM_PARENT(
  INDENT, ID, PARENT_ITEM_ID, TEXT, PERSISTENT_ID, 
  DELIVERABLE_ID, DICTIONARY_ID
) AS (
  SELECT 
    '' AS INDENT, 
    DICTIONARY_ITEM.ID, 
    TO_NUMBER(PARENT_ITEM_ID) AS PARENT_ITEM_ID, 
    TEXT, 
    PERSISTENT_ID, 
    DICTIONARY_ITEM.DELIVERABLE_ID, 
    DICTIONARY_ID 
  FROM 
    "DEV_DATAMART_DB"."DEV_DICTIONARY"."DICTIONARY_ITEM" 
    JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."ITEM_TEXT" AS ITEM_TEXT ON DICTIONARY_ITEM.TEXT_ID = ITEM_TEXT.ID 
    JOIN DEV_DATAMART_DB.DEV_DICTIONARY.VW_DICTIONARY_ITEM_TYPE as DICTIONARY_ITEM_TYPE ON DICTIONARY_ITEM.TYPE_ID = DICTIONARY_ITEM_TYPE.ID 
  WHERE 
    PARENT_ITEM_ID IS NULL 
  UNION ALL 
  SELECT 
    INDENT || DICTIONARY_ITEM_PARENT.TEXT || '|', 
    DICTIONARY_ITEM.ID, 
    DICTIONARY_ITEM.PARENT_ITEM_ID, 
    DICTIONARY_ITEM.TEXT, 
    DICTIONARY_ITEM.PERSISTENT_ID, 
    DICTIONARY_ITEM.DELIVERABLE_ID, 
    DICTIONARY_ITEM.DICTIONARY_ID 
  FROM 
    (
      SELECT 
        DICTIONARY_ITEM.ID, 
        TO_NUMBER(PARENT_ITEM_ID) AS PARENT_ITEM_ID, 
        TEXT, 
        PERSISTENT_ID, 
        DICTIONARY_ITEM.DELIVERABLE_ID, 
        DICTIONARY_ITEM.DICTIONARY_ID 
      FROM 
        "DEV_DATAMART_DB"."DEV_DICTIONARY"."DICTIONARY_ITEM" 
        JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."ITEM_TEXT" AS ITEM_TEXT ON DICTIONARY_ITEM.TEXT_ID = ITEM_TEXT.ID 
        JOIN DEV_DATAMART_DB.DEV_DICTIONARY.VW_DICTIONARY_ITEM_TYPE as DICTIONARY_ITEM_TYPE ON DICTIONARY_ITEM.TYPE_ID = DICTIONARY_ITEM_TYPE.ID
    ) AS DICTIONARY_ITEM 
    JOIN DICTIONARY_ITEM_PARENT ON DICTIONARY_ITEM_PARENT.ID = DICTIONARY_ITEM.PARENT_ITEM_ID
),
PROCESSED_DICTIONARY_ITEM as(
  select 
    DICTIONARY_ID,
    ID as DICTIONARY_ITEM_ID,
    INDENT || TEXT as HIERARCHY_TEXT, 
    PERSISTENT_ID 
  from 
    DICTIONARY_ITEM_PARENT 
  where 
    DELIVERABLE_ID = 1 
    and DICTIONARY_ID = (
      select 
        DICTIONARY_ID 
      from 
        "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."STUDY_STG"
    )
)

select
  STUDY_STG.DICTIONARY_ID, 
  PROCESSED_DICTIONARY_ITEM.DICTIONARY_ITEM_ID,
  VW_STUDY_FAMILY.ID as STUDY_FAMILY_ID,
  ATTRIBUTE_MASTER.ID as ATTRIBUTE_MASTER_ID,
  PROCESSED_DICTIONARY_ITEM.PERSISTENT_ID,
  TRUE as ACTIVE,
  CURRENT_TIMESTAMP AS CRT_TS, 
  VW_USER_INFO.ID AS CRT_BY, 
  NULL AS UPD_BY, 
  NULL AS UPD_TS,
  IS_STUDYATTRIBUTE
   
from 
  "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."ATTRIBUTE_STG" 
  join "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."STUDY_STG" on ATTRIBUTE_STG.DP_STUDY_ID = STUDY_STG.DP_STUDY_ID 
  left join DEV_DATAMART_DB.DEV_DICTIONARY.VW_STUDY_FAMILY on STUDY_STG.STUDY_FAMILY = VW_STUDY_FAMILY.STUDY_FAMILY
  join "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_USER_INFO" on VW_USER_INFO.FIRST_NAME = 'ETL_USER' 
  join "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_ATTRIBUTE_TYPE" on VW_ATTRIBUTE_TYPE.ATTRIBUTE_TYPE = UPPER(ATTRIBUTE_STG.ATTRIBUTE_TYPE) 
  join "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_ATTRIBUTE" on VW_ATTRIBUTE.NAME = ATTRIBUTE_STG.ATTRIBUTE 
  join "DEV_DATAMART_DB"."DEV_DICTIONARY"."ATTRIBUTE_MASTER" on ATTRIBUTE_MASTER.ATTRIBUTE_TYPE_ID = VW_ATTRIBUTE_TYPE.ATTRIBUTE_TYPE_ID 
  and ATTRIBUTE_MASTER.ATTRIBUTE_VALUE = ATTRIBUTE_STG.ATTRIBUTE_VALUE 
  and ATTRIBUTE_MASTER.ATTRIBUTE_ID = VW_ATTRIBUTE.ID
  left join PROCESSED_DICTIONARY_ITEM on PROCESSED_DICTIONARY_ITEM.HIERARCHY_TEXT = ATTRIBUTE_STG.HIERARCHY_TEXT
;


create or replace view VW_DICTIONARY_COMPARE(
	STUDY_ID,
	ACTION_TYPE_ID,
	MESSAGE,
	OLD_VALUE,
	NEW_VALUE,
	CRT_TS,
	UPD_BY,
	UPD_TS,
	FIELD,
	CRT_BY,
	DICTIONARY_ID,
	IS_NEW_VALUE
) as 

WITH STAGING_DICTIONARY AS (
  SELECT 
    ID :: STRING AS ID, 
    STUDY_ID :: STRING AS STUDY_ID, 
    DB_VERSIONID :: STRING AS DB_VERSIONID, 
    CRT_BY :: STRING AS CRT_BY, 
    UPD_BY :: STRING AS UPD_BY, 
    CRT_TS :: STRING as CRT_TS, 
    UPD_TS :: STRING as UPD_TS, 
    VERSION :: STRING AS VERSION, 
    STATUS_ID :: STRING AS STATUS_ID, 
    COMMENT :: STRING AS COMMENT, 
    SOURCE_PARENT_ID :: STRING AS SOURCE_PARENT_ID, 
    SOURCE_ID :: STRING AS SOURCE_ID, 
    TO_TIMESTAMP(VERSION_RELEASE_DATE) :: STRING AS VERSION_RELEASE_DATE 
  FROM 
    "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."VW_DICTIONARY_STG"
), 
DATAMART_DICTIONARY AS (
  SELECT 
    ID :: STRING AS ID, 
    VERSION :: STRING AS VERSION, 
    STATUS_ID :: STRING AS STATUS_ID, 
    COMMENT :: STRING AS COMMENT, 
    SOURCE_PARENT_ID :: STRING AS SOURCE_PARENT_ID, 
    SOURCE_ID :: STRING AS SOURCE_ID, 
    VERSION_RELEASE_DATE :: STRING AS VERSION_RELEASE_DATE 
  FROM 
    "DEV_DATAMART_DB"."DEV_DICTIONARY"."DICTIONARY" 
  WHERE 
    ID IN (
      SELECT 
        ID 
      FROM 
        "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."VW_DICTIONARY_STG"
    )
) 
SELECT 
  UNPIVOTED_STAGING_DICTIONARY.STUDY_ID AS STUDY_ID, 
  VW_ACTION_TYPE.ID AS ACTION_TYPE_ID, 
  '' AS MESSAGE, 
  UNPIVOTED_DATAMART_DICTIONARY.DATAMART_VALUE AS OLD_VALUE, 
  UNPIVOTED_STAGING_DICTIONARY.STAGE_VALUE AS NEW_VALUE, 
  CURRENT_TIMESTAMP AS CRT_TS, 
  NULL as UPD_BY, 
  NULL as UPD_TS, 
  UNPIVOTED_STAGING_DICTIONARY.COLUMN_NAME AS FIELD, 
  VW_USER_INFO.ID AS CRT_BY, 
  UNPIVOTED_STAGING_DICTIONARY.ID AS DICTIONARY_ID, 
  UNPIVOTED_DATAMART_DICTIONARY.DATAMART_VALUE != UNPIVOTED_STAGING_DICTIONARY.STAGE_VALUE AS IS_NEW_VALUE 
FROM 
  DATAMART_DICTIONARY UNPIVOT(
    DATAMART_VALUE FOR COLUMN_NAME IN (
      STATUS_ID, COMMENT, SOURCE_PARENT_ID, 
      SOURCE_ID, VERSION_RELEASE_DATE
    )
  ) AS UNPIVOTED_DATAMART_DICTIONARY 
  JOIN STAGING_DICTIONARY UNPIVOT(
    STAGE_VALUE FOR COLUMN_NAME IN (
      STATUS_ID, COMMENT, SOURCE_PARENT_ID, 
      SOURCE_ID, VERSION_RELEASE_DATE
    )
  ) AS UNPIVOTED_STAGING_DICTIONARY ON UNPIVOTED_STAGING_DICTIONARY.ID = UNPIVOTED_DATAMART_DICTIONARY.ID 
  AND UNPIVOTED_STAGING_DICTIONARY.COLUMN_NAME = UNPIVOTED_DATAMART_DICTIONARY.COLUMN_NAME 
  JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_ACTION_TYPE" on UPPER(VW_ACTION_TYPE.NAME) = 'UPDATE'
  JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_USER_INFO" on VW_USER_INFO.FIRST_NAME = 'ETL_USER'
WHERE 
  IS_NEW_VALUE = TRUE or IS_NEW_VALUE is NULL;
  
  
create or replace view VW_DICTIONARY_ITEM(
	DICTIONARY_ITEM_ID,
	DICTIONARY_ID,
	DP_STUDY_ID,
	KEYWORD,
	TYPE_ID,
	PARENT_ID,
	TEXT_ID,
	DICTIONARY_ITEM_TYPE,
	IS_Q_LEVEL,
	ACCESS_CODE,
	DISPLAY_TYPE,
	DATA_TYPE_ID,
	FIRST_WAVE,
	IS_NEW,
	MIN,
	MAX,
	CCP,
	EXTERNAL_KEY,
	PERSISTENT_ID,
	MEMRI_DEFINITION,
	SORT,
	DELIVERABLE_ID,
	ACTIVE,
	CRT_TS,
	CRT_BY,
	UPD_BY,
	UPD_TS,
	LEAF_LEVEL,
	DICTIONARY_ITEM_SORT,
	FULL_ARRAY_SLICE,
	HIERARCHY_TEXT,
	TO_INSERT,
	IS_LEAF_NODE,
	IS_DEFINITION,
	IS_STANDARD,
	FULL_LABEL
) as 

WITH INSIGHT_DICTIONARY_ITEM AS (
  select 
    DICTIONARY_ITEM_ID, 
    DICTIONARY_ID, 
    DP_STUDY_ID, 
    KEYWORD, 
    TYPE_ID, 
    PARENT_ID, 
    TEXT_ID, 
    DICTIONARY_ITEM_TYPE, 
    IS_Q_LEVEL, 
    ACCESS_CODE, 
    DISPLAY_TYPE, 
    DATA_TYPE_ID, 
    FIRST_WAVE, 
    IS_NEW, 
    MIN, 
    MAX, 
    CCP, 
    EXTERNAL_KEY as DICTIONARY_EXTERNAL_KEY, 
    CASE WHEN EXTERNAL_KEY = 'U0' THEN NULL ELSE EXTERNAL_KEY END AS EXTERNAL_KEY, 
    PERSISTENT_ID, 
    MEMRI_DEFINITION, 
    SORT, 
    DELIVERABLE_ID, 
    ACTIVE, 
    CRT_TS, 
    CRT_BY, 
    UPD_BY, 
    UPD_TS, 
    NULL as LEAF_LEVEL, 
    DICTIONARY_ITEM_SORT, 
    FULL_ARRAY_SLICE, 
    CASE WHEN DICTIONARY_ITEM_TYPE = 'a' THEN FULL_LABEL ELSE NULL END AS FULL_LABEL 
  from 
    "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."VW_INSIGHT_DICTIONARY_ITEM"
), 
MEMRI_DICTIONARY_ITEM AS (
  select 
    DICTIONARY_ITEM_ID, 
    DICTIONARY_ID, 
    DP_STUDY_ID, 
    KEYWORD, 
    TYPE_ID, 
    PARENT_ID, 
    TEXT_ID, 
    DICTIONARY_ITEM_TYPE, 
    IS_Q_LEVEL, 
    ACCESS_CODE, 
    DISPLAY_TYPE, 
    DATA_TYPE_ID, 
    FIRST_WAVE, 
    IS_NEW, 
    MIN, 
    MAX, 
    CCP, 
    EXTERNAL_KEY as DICTIONARY_EXTERNAL_KEY, 
    CASE WHEN EXTERNAL_KEY = 'U0' THEN NULL ELSE EXTERNAL_KEY END AS EXTERNAL_KEY, 
    PERSISTENT_ID, 
    MEMRI_DEFINITION, 
    SORT, 
    DELIVERABLE_ID, 
    ACTIVE, 
    CRT_TS, 
    CRT_BY, 
    UPD_BY, 
    UPD_TS, 
    LEAF_LEVEL, 
    DICTIONARY_ITEM_SORT, 
    FULL_ARRAY_SLICE, 
    CASE WHEN LEAF_LEVEL = TRUE THEN FULL_LABEL ELSE NULL END AS FULL_LABEL 
  from 
    "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."VW_MEMRI_DICTIONARY_ITEM"
), 
MASTER_LOOKUP_UNIQUE_EXTERNAL_KEY AS(
  SELECT 
    * 
  FROM 
    "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_MASTER_LOOKUP" as VW_MASTER_LOOKUP QUALIFY ROW_NUMBER() OVER (
      PARTITION BY EXTERNAL_KEYWORD 
      ORDER BY 
        EXTERNAL_KEYWORD
    ) = 1
), 
PROCESSED_DICTIONARY AS (
  SELECT 
    DICTIONARY_ITEM_ID, 
    FULL_ARRAY_SLICE, 
    CASE WHEN DICTIONARY_ITEM_TYPE = 'a' THEN TRUE ELSE FALSE END AS IS_LEAF_NODE, 
    CASE WHEN DICTIONARY_ITEM_TYPE = 'a' THEN 'X' ELSE 'H' END AS PREFIX, 
    CASE WHEN DICTIONARY_ITEM_TYPE = 'a' THEN EXTERNAL_KEY ELSE NULL END AS EXTERNAL_KEY, 
    IS_CUSTOMQUESTION AS SKIP_SUPER_CATEGORY, 
    FALSE AS APPLY_FUZZY_LOGIC, 
    DELIVERABLE_ID, 
    LEAF_LEVEL, 
    DICTIONARY_ITEM_TYPE, 
    CASE WHEN DICTIONARY_ITEM_TYPE = 'a' 
    OR LEAF_LEVEL = TRUE THEN KEYWORD ELSE NULL END AS KEYWORD, 
    VW_STUDY_TYPE.ID as STUDY_TYPE, 
    VW_STUDY_FAMILY.STUDY_FAMILY, 
    ARRAY_TO_STRING(FULL_ARRAY_SLICE, '|') as HIERARCHY_TEXT 
  FROM 
    INSIGHT_DICTIONARY_ITEM 
    JOIN "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."VW_STUDY_STG" ON INSIGHT_DICTIONARY_ITEM.DICTIONARY_ID = VW_STUDY_STG.DICTIONARY_ID 
    JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_STUDY_FAMILY" ON VW_STUDY_FAMILY.ID = VW_STUDY_STG.STUDY_FAMILY_ID 
    JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_STUDY_TYPE" ON VW_STUDY_TYPE.ID = VW_STUDY_STG.STUDY_TYPE_ID
), 
PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY as(
  SELECT 
    PROCESSED_DICTIONARY.DICTIONARY_ITEM_ID, 
    PROCESSED_DICTIONARY.FULL_ARRAY_SLICE, 
    PROCESSED_DICTIONARY.IS_LEAF_NODE, 
    PROCESSED_DICTIONARY.PREFIX, 
    PROCESSED_DICTIONARY.EXTERNAL_KEY, 
    PROCESSED_DICTIONARY.SKIP_SUPER_CATEGORY, 
    PROCESSED_DICTIONARY.APPLY_FUZZY_LOGIC, 
    PROCESSED_DICTIONARY.DELIVERABLE_ID, 
    PROCESSED_DICTIONARY.LEAF_LEVEL, 
    PROCESSED_DICTIONARY.DICTIONARY_ITEM_TYPE, 
    PROCESSED_DICTIONARY.KEYWORD, 
    PROCESSED_DICTIONARY.STUDY_TYPE, 
    PROCESSED_DICTIONARY.STUDY_FAMILY, 
    CASE WHEN PROCESSED_DICTIONARY.SKIP_SUPER_CATEGORY = TRUE 
    AND PROCESSED_DICTIONARY.DICTIONARY_ITEM_TYPE != 'c' THEN SUBSTR(
      PROCESSED_DICTIONARY.HIERARCHY_TEXT, 
      CHARINDEX(
        '|', PROCESSED_DICTIONARY.HIERARCHY_TEXT, 
        1
      )+ 1, 
      LENGTH(
        PROCESSED_DICTIONARY.HIERARCHY_TEXT
      )
    ) ELSE PROCESSED_DICTIONARY.HIERARCHY_TEXT END AS HIERARCHY_TEXT 
  FROM 
    PROCESSED_DICTIONARY
), 
EXTERNAL_KEYWORD AS (
  SELECT 
    PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY.DICTIONARY_ITEM_ID, 
    PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY.FULL_ARRAY_SLICE, 
    PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY.IS_LEAF_NODE, 
    PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY.PREFIX, 
    PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY.EXTERNAL_KEY, 
    PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY.SKIP_SUPER_CATEGORY, 
    PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY.APPLY_FUZZY_LOGIC, 
    PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY.DELIVERABLE_ID, 
    PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY.LEAF_LEVEL, 
    PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY.DICTIONARY_ITEM_TYPE, 
    PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY.KEYWORD, 
    PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY.STUDY_TYPE, 
    PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY.STUDY_FAMILY, 
    LOWER(
      "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE".FN_CLEAN_HIERARCHY_TEXT(
        PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY.HIERARCHY_TEXT, 
        PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY.STUDY_TYPE
      )
    ) as HIERARCHY_TEXT,
    PERSISTENT_ID 
  FROM 
    PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY 
    LEFT JOIN MASTER_LOOKUP_UNIQUE_EXTERNAL_KEY ON LOWER(
      PROCESSED_DICTIONARY_SKIP_SUPER_CATEGORY.EXTERNAL_KEY
    ) = LOWER(
      MASTER_LOOKUP_UNIQUE_EXTERNAL_KEY.EXTERNAL_KEYWORD
    )
), 
MASTER_LOOKUP_UNIQUE_FULL_LABEL AS(
  SELECT 
    * 
  FROM 
    "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_MASTER_LOOKUP" as VW_MASTER_LOOKUP QUALIFY ROW_NUMBER() OVER (
      PARTITION BY LOWER(
        VW_MASTER_LOOKUP.HIERARCHY_TEXT
      ), 
      IS_LEAF 
      ORDER BY 
        HIERARCHY_TEXT
    ) = 1
), 
STUDY_HEIRARCHY_TEXT AS(
  SELECT 
    DICTIONARY_ITEM_ID, 
    EXTERNAL_KEYWORD.HIERARCHY_TEXT, 
    EXTERNAL_KEYWORD.IS_LEAF_NODE, 
    EXTERNAL_KEYWORD.PREFIX, 
    EXTERNAL_KEYWORD.EXTERNAL_KEY, 
    EXTERNAL_KEYWORD.SKIP_SUPER_CATEGORY, 
    EXTERNAL_KEYWORD.APPLY_FUZZY_LOGIC, 
    EXTERNAL_KEYWORD.DELIVERABLE_ID, 
    EXTERNAL_KEYWORD.KEYWORD, 
    EXTERNAL_KEYWORD.STUDY_TYPE, 
    MASTER_LOOKUP_UNIQUE_FULL_LABEL.PERSISTENT_ID, 
    LEAF_LEVEL, 
    DICTIONARY_ITEM_TYPE 
  FROM 
    EXTERNAL_KEYWORD 
    LEFT JOIN MASTER_LOOKUP_UNIQUE_FULL_LABEL ON LOWER(
      EXTERNAL_KEYWORD.HIERARCHY_TEXT
    ) = LOWER(
      MASTER_LOOKUP_UNIQUE_FULL_LABEL.HIERARCHY_TEXT
    ) 
    AND MASTER_LOOKUP_UNIQUE_FULL_LABEL.IS_LEAF = EXTERNAL_KEYWORD.IS_LEAF_NODE 
  WHERE 
    EXTERNAL_KEYWORD.PERSISTENT_ID IS NULL 
    and DELIVERABLE_ID = 1
), 
MASTER_LOOKUP_UNIQUE_FULL_LABEL_REMOVED_PUNTUATION AS(
  SELECT 
    * 
  FROM 
    "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_MASTER_LOOKUP" as VW_MASTER_LOOKUP QUALIFY ROW_NUMBER() OVER (
      PARTITION BY LOWER(
        REGEXP_REPLACE(
          VW_MASTER_LOOKUP.HIERARCHY_TEXT, 
          '[!,*,.,:,;, _,\,]'
        )
      ), 
      IS_LEAF 
      ORDER BY 
        PERSISTENT_ID
    ) = 1
), 
STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION as (
  SELECT 
    STUDY_HEIRARCHY_TEXT.DICTIONARY_ITEM_ID, 
    STUDY_HEIRARCHY_TEXT.HIERARCHY_TEXT, 
    STUDY_HEIRARCHY_TEXT.STUDY_TYPE, 
    STUDY_HEIRARCHY_TEXT.IS_LEAF_NODE, 
    STUDY_HEIRARCHY_TEXT.PREFIX, 
    STUDY_HEIRARCHY_TEXT.EXTERNAL_KEY, 
    STUDY_HEIRARCHY_TEXT.SKIP_SUPER_CATEGORY, 
    STUDY_HEIRARCHY_TEXT.APPLY_FUZZY_LOGIC, 
    STUDY_HEIRARCHY_TEXT.DELIVERABLE_ID, 
    STUDY_HEIRARCHY_TEXT.KEYWORD, 
    MASTER_LOOKUP_UNIQUE_FULL_LABEL_REMOVED_PUNTUATION.PERSISTENT_ID, 
    STUDY_HEIRARCHY_TEXT.LEAF_LEVEL, 
    STUDY_HEIRARCHY_TEXT.DICTIONARY_ITEM_TYPE 
  FROM 
    STUDY_HEIRARCHY_TEXT 
    LEFT JOIN MASTER_LOOKUP_UNIQUE_FULL_LABEL_REMOVED_PUNTUATION on LOWER(
      REGEXP_REPLACE(
        MASTER_LOOKUP_UNIQUE_FULL_LABEL_REMOVED_PUNTUATION.HIERARCHY_TEXT, 
        '[!,*,.,:,;,_ ,\,]'
      )
    ) = LOWER(
      REGEXP_REPLACE(
        STUDY_HEIRARCHY_TEXT.HIERARCHY_TEXT, 
        '[!,*,.,:,;,_ ,\,]'
      )
    ) AND MASTER_LOOKUP_UNIQUE_FULL_LABEL_REMOVED_PUNTUATION.IS_LEAF = STUDY_HEIRARCHY_TEXT.IS_LEAF_NODE
  where 
    STUDY_HEIRARCHY_TEXT.PERSISTENT_ID is NULL
), 
STUDY_HEIRARCHY_TEXT_ADD_PERSISTENT_ID as (
  SELECT 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.HIERARCHY_TEXT, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.IS_LEAF_NODE, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.PREFIX || "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."SEQ_PERSISTENT_ID".NEXTVAL AS PERSISTENT_ID 
  FROM 
    (
      SELECT 
        * 
      FROM 
        STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION 
      WHERE 
        STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.KEYWORD IS NULL 
        and PERSISTENT_ID is NULL
    ) as STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION QUALIFY ROW_NUMBER() OVER (
      PARTITION BY HIERARCHY_TEXT, 
      IS_LEAF_NODE 
      ORDER BY 
        HIERARCHY_TEXT
    ) = 1
), 
ITEM_TO_INSERT as (
  SELECT 
    DICTIONARY_ITEM_ID, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.HIERARCHY_TEXT, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.IS_LEAF_NODE, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.PREFIX, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.EXTERNAL_KEY, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.SKIP_SUPER_CATEGORY, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.APPLY_FUZZY_LOGIC, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.DELIVERABLE_ID, 
    STUDY_HEIRARCHY_TEXT_ADD_PERSISTENT_ID.PERSISTENT_ID, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.KEYWORD, 
    TRUE AS TO_INSERT 
  FROM 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION 
    JOIN STUDY_HEIRARCHY_TEXT_ADD_PERSISTENT_ID ON STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.HIERARCHY_TEXT = STUDY_HEIRARCHY_TEXT_ADD_PERSISTENT_ID.HIERARCHY_TEXT 
    AND STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.IS_LEAF_NODE = STUDY_HEIRARCHY_TEXT_ADD_PERSISTENT_ID.IS_LEAF_NODE 
  WHERE 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.KEYWORD IS NULL 
    and STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.PERSISTENT_ID is NULL 
  UNION ALL 
  SELECT 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.DICTIONARY_ITEM_ID, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.HIERARCHY_TEXT, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.IS_LEAF_NODE, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.PREFIX, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.EXTERNAL_KEY, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.SKIP_SUPER_CATEGORY, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.APPLY_FUZZY_LOGIC, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.DELIVERABLE_ID, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.KEYWORD AS PERSISTENT_ID, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.KEYWORD, 
    TRUE AS TO_INSERT 
  FROM 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION 
  WHERE 
    KEYWORD IS NOT NULL 
    and PERSISTENT_ID is NULL
), 
ITEM_WITH_PERSISTENT_ID as(
  SELECT 
    DICTIONARY_ITEM_ID, 
    EXTERNAL_KEYWORD.HIERARCHY_TEXT, 
    EXTERNAL_KEYWORD.IS_LEAF_NODE, 
    EXTERNAL_KEYWORD.PREFIX, 
    EXTERNAL_KEYWORD.EXTERNAL_KEY, 
    EXTERNAL_KEYWORD.SKIP_SUPER_CATEGORY, 
    EXTERNAL_KEYWORD.APPLY_FUZZY_LOGIC, 
    EXTERNAL_KEYWORD.DELIVERABLE_ID, 
    EXTERNAL_KEYWORD.PERSISTENT_ID, 
    EXTERNAL_KEYWORD.KEYWORD, 
    FALSE AS TO_INSERT 
  FROM 
    EXTERNAL_KEYWORD 
  WHERE 
    PERSISTENT_ID is NOT NULL 
  UNION ALL 
  SELECT 
    DICTIONARY_ITEM_ID, 
    STUDY_HEIRARCHY_TEXT.HIERARCHY_TEXT, 
    STUDY_HEIRARCHY_TEXT.IS_LEAF_NODE, 
    STUDY_HEIRARCHY_TEXT.PREFIX, 
    STUDY_HEIRARCHY_TEXT.EXTERNAL_KEY, 
    STUDY_HEIRARCHY_TEXT.SKIP_SUPER_CATEGORY, 
    STUDY_HEIRARCHY_TEXT.APPLY_FUZZY_LOGIC, 
    STUDY_HEIRARCHY_TEXT.DELIVERABLE_ID, 
    STUDY_HEIRARCHY_TEXT.PERSISTENT_ID, 
    STUDY_HEIRARCHY_TEXT.KEYWORD, 
    FALSE AS TO_INSERT 
  FROM 
    STUDY_HEIRARCHY_TEXT 
  WHERE 
    PERSISTENT_ID is NOT NULL 
  UNION ALL 
  SELECT 
    DICTIONARY_ITEM_ID, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.HIERARCHY_TEXT, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.IS_LEAF_NODE, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.PREFIX, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.EXTERNAL_KEY, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.SKIP_SUPER_CATEGORY, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.APPLY_FUZZY_LOGIC, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.DELIVERABLE_ID, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.PERSISTENT_ID, 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION.KEYWORD, 
    FALSE AS TO_INSERT 
  FROM 
    STUDY_HEIRARCHY_TEXT_REMOVED_PUNTUATION 
  WHERE 
    PERSISTENT_ID is NOT NULL
), 
PERSISTENT_ID as (
  SELECT 
    * 
  FROM 
    ITEM_WITH_PERSISTENT_ID 
  UNION ALL 
  SELECT 
    * 
  FROM 
    ITEM_TO_INSERT
), 
INSIGHT_DICTIONARY_ITEM_WITH_PERSISTENT_ID as (
  SELECT 
    INSIGHT_DICTIONARY_ITEM.DICTIONARY_ITEM_ID, 
    INSIGHT_DICTIONARY_ITEM.DICTIONARY_ID, 
    INSIGHT_DICTIONARY_ITEM.DP_STUDY_ID, 
    INSIGHT_DICTIONARY_ITEM.KEYWORD, 
    INSIGHT_DICTIONARY_ITEM.TYPE_ID, 
    INSIGHT_DICTIONARY_ITEM.PARENT_ID, 
    INSIGHT_DICTIONARY_ITEM.TEXT_ID, 
    INSIGHT_DICTIONARY_ITEM.DICTIONARY_ITEM_TYPE, 
    INSIGHT_DICTIONARY_ITEM.IS_Q_LEVEL, 
    INSIGHT_DICTIONARY_ITEM.ACCESS_CODE, 
    INSIGHT_DICTIONARY_ITEM.DISPLAY_TYPE, 
    INSIGHT_DICTIONARY_ITEM.DATA_TYPE_ID, 
    INSIGHT_DICTIONARY_ITEM.FIRST_WAVE, 
    INSIGHT_DICTIONARY_ITEM.IS_NEW, 
    INSIGHT_DICTIONARY_ITEM.MIN, 
    INSIGHT_DICTIONARY_ITEM.MAX, 
    INSIGHT_DICTIONARY_ITEM.CCP, 
    INSIGHT_DICTIONARY_ITEM.DICTIONARY_EXTERNAL_KEY as EXTERNAL_KEY, 
    PERSISTENT_ID.PERSISTENT_ID, 
    INSIGHT_DICTIONARY_ITEM.MEMRI_DEFINITION, 
    INSIGHT_DICTIONARY_ITEM.SORT, 
    INSIGHT_DICTIONARY_ITEM.DELIVERABLE_ID, 
    INSIGHT_DICTIONARY_ITEM.ACTIVE, 
    INSIGHT_DICTIONARY_ITEM.CRT_TS, 
    INSIGHT_DICTIONARY_ITEM.CRT_BY, 
    INSIGHT_DICTIONARY_ITEM.UPD_BY, 
    INSIGHT_DICTIONARY_ITEM.UPD_TS, 
    INSIGHT_DICTIONARY_ITEM.LEAF_LEVEL, 
    INSIGHT_DICTIONARY_ITEM.DICTIONARY_ITEM_SORT, 
    INSIGHT_DICTIONARY_ITEM.FULL_ARRAY_SLICE, 
    PERSISTENT_ID.HIERARCHY_TEXT, 
    PERSISTENT_ID.TO_INSERT, 
    PERSISTENT_ID.IS_LEAF_NODE, 
    FALSE AS IS_DEFINITION, 
    TRUE AS IS_STANDARD, 
    INSIGHT_DICTIONARY_ITEM.FULL_LABEL 
  FROM 
    INSIGHT_DICTIONARY_ITEM 
    JOIN PERSISTENT_ID ON INSIGHT_DICTIONARY_ITEM.DICTIONARY_ITEM_ID = PERSISTENT_ID.DICTIONARY_ITEM_ID
), 
MEMRI_DICTIONARY_ITEM_WITH_PERSISTENT_ID as (
  SELECT 
    MEMRI_DICTIONARY_ITEM.DICTIONARY_ITEM_ID, 
    MEMRI_DICTIONARY_ITEM.DICTIONARY_ID, 
    MEMRI_DICTIONARY_ITEM.DP_STUDY_ID, 
    MEMRI_DICTIONARY_ITEM.KEYWORD, 
    MEMRI_DICTIONARY_ITEM.TYPE_ID, 
    MEMRI_DICTIONARY_ITEM.PARENT_ID, 
    MEMRI_DICTIONARY_ITEM.TEXT_ID, 
    MEMRI_DICTIONARY_ITEM.DICTIONARY_ITEM_TYPE, 
    MEMRI_DICTIONARY_ITEM.IS_Q_LEVEL, 
    MEMRI_DICTIONARY_ITEM.ACCESS_CODE, 
    MEMRI_DICTIONARY_ITEM.DISPLAY_TYPE, 
    MEMRI_DICTIONARY_ITEM.DATA_TYPE_ID, 
    MEMRI_DICTIONARY_ITEM.FIRST_WAVE, 
    MEMRI_DICTIONARY_ITEM.IS_NEW, 
    MEMRI_DICTIONARY_ITEM.MIN, 
    MEMRI_DICTIONARY_ITEM.MAX, 
    MEMRI_DICTIONARY_ITEM.CCP, 
    MEMRI_DICTIONARY_ITEM.DICTIONARY_EXTERNAL_KEY as EXTERNAL_KEY, 
    INSIGHT_DICTIONARY_ITEM_WITH_PERSISTENT_ID.PERSISTENT_ID, 
    MEMRI_DICTIONARY_ITEM.MEMRI_DEFINITION, 
    MEMRI_DICTIONARY_ITEM.SORT, 
    MEMRI_DICTIONARY_ITEM.DELIVERABLE_ID, 
    MEMRI_DICTIONARY_ITEM.ACTIVE, 
    MEMRI_DICTIONARY_ITEM.CRT_TS, 
    MEMRI_DICTIONARY_ITEM.CRT_BY, 
    MEMRI_DICTIONARY_ITEM.UPD_BY, 
    MEMRI_DICTIONARY_ITEM.UPD_TS, 
    MEMRI_DICTIONARY_ITEM.LEAF_LEVEL, 
    MEMRI_DICTIONARY_ITEM.DICTIONARY_ITEM_SORT, 
    MEMRI_DICTIONARY_ITEM.FULL_ARRAY_SLICE, 
    NULL AS HIERARCHY_TEXT, 
    FALSE AS TO_INSERT, 
    FALSE AS IS_LEAF_NODE, 
    FALSE AS IS_DEFINITION, 
    TRUE AS IS_STANDARD, 
    MEMRI_DICTIONARY_ITEM.FULL_LABEL 
  FROM 
    MEMRI_DICTIONARY_ITEM 
    LEFT JOIN INSIGHT_DICTIONARY_ITEM_WITH_PERSISTENT_ID ON INSIGHT_DICTIONARY_ITEM_WITH_PERSISTENT_ID.FULL_LABEL = MEMRI_DICTIONARY_ITEM.FULL_LABEL
) 
SELECT 
  * 
FROM 
  INSIGHT_DICTIONARY_ITEM_WITH_PERSISTENT_ID 

UNION ALL 

SELECT 
  * 
FROM 
  MEMRI_DICTIONARY_ITEM_WITH_PERSISTENT_ID ;
  

create or replace view VW_STUDY_COMPARE(
	STUDY_ID,
	ACTION_TYPE_ID,
	MESSAGE,
	OLD_VALUE,
	NEW_VALUE,
	CRT_TS,
	UPD_BY,
	UPD_TS,
	FIELD,
	CRT_BY,
	DICTIONARY_ID,
	IS_NEW_VALUE
) as




WITH STAGING_STUDY AS (
  SELECT 
    ID :: STRING AS ID, 
    DICTIONARY_ID :: STRING AS DICTIONARY_ID,
    CRT_BY :: STRING AS CRT_BY, 
    UPD_BY :: STRING AS UPD_BY,
    CRT_TS :: STRING as CRT_TS,
    UPD_TS :: STRING as UPD_TS,
    NAME :: STRING AS NAME, 
    STUDY_FAMILY_ID :: STRING AS STUDY_FAMILY_ID, 
    STUDY_RELEASE_ID :: STRING AS STUDY_RELEASE_ID, 
    STUDY_TYPE_ID :: STRING AS STUDY_TYPE_ID, 
    STUDY_CODE :: STRING AS STUDY_CODE, 
    SECURITYCODE :: STRING AS SECURITYCODE, 
    RELEASE_DATE :: STRING AS RELEASE_DATE, 
    YEAR :: STRING AS YEAR, 
    TREND_FAMILY_ID :: STRING AS TREND_FAMILY_ID, 
    MINWAVE :: STRING AS MINWAVE, 
    MAXWAVE :: STRING AS MAXWAVE, 
    TO_DATE(STARTFIELDDATE) :: STRING AS STARTFIELDDATE, 
    TO_DATE(ENDFIELDDATE) :: STRING AS ENDFIELDDATE, 
    USEEXTERNALKEY :: STRING AS USEEXTERNALKEY, 
    ACTIVE :: STRING AS ACTIVE, 
    PARENT_STUDY_ID :: STRING AS PARENT_STUDY_ID, 
    DP_STUDYID :: STRING AS DP_STUDYID, 
    HIDE :: STRING AS HIDE 
  FROM 
    "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."VW_STUDY_STG"
), 
DATAMART_STUDY AS (
  SELECT 
    ID :: STRING AS ID, 
    NAME :: STRING AS NAME, 
    STUDY_FAMILY_ID :: STRING AS STUDY_FAMILY_ID, 
    STUDY_RELEASE_ID :: STRING AS STUDY_RELEASE_ID, 
    STUDY_TYPE_ID :: STRING AS STUDY_TYPE_ID, 
    STUDY_CODE :: STRING AS STUDY_CODE, 
    SECURITYCODE :: STRING AS SECURITYCODE, 
    RELEASE_DATE :: STRING AS RELEASE_DATE, 
    YEAR :: STRING AS YEAR, 
    TREND_FAMILY_ID :: STRING AS TREND_FAMILY_ID, 
    MINWAVE :: STRING AS MINWAVE, 
    MAXWAVE :: STRING AS MAXWAVE, 
    STARTFIELDDATE :: STRING AS STARTFIELDDATE, 
    ENDFIELDDATE :: STRING AS ENDFIELDDATE, 
    USEEXTERNALKEY :: STRING AS USEEXTERNALKEY, 
    ACTIVE :: STRING AS ACTIVE, 
    PARENT_STUDY_ID :: STRING AS PARENT_STUDY_ID, 
    DP_STUDYID :: STRING AS DP_STUDYID, 
    HIDE :: STRING AS HIDE 
  FROM 
    "DEV_DATAMART_DB"."DEV_DICTIONARY"."STUDY" 
  WHERE 
    ID IN (
      SELECT 
        ID 
      FROM 
        "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."VW_STUDY_STG"
    )
) 
SELECT 
  UNPIVOTED_STAGING_STUDY.ID AS STUDY_ID, 
  VW_ACTION_TYPE.ID AS ACTION_TYPE_ID, 
  '' AS MESSAGE, 
  UNPIVOTED_DATAMART_STUDY.DATAMART_VALUE AS OLD_VALUE, 
  UNPIVOTED_STAGING_STUDY.STAGE_VALUE AS NEW_VALUE, 
  CURRENT_TIMESTAMP AS CRT_TS,  
  NULL as UPD_BY, 
  NULL as UPD_TS, 
  UNPIVOTED_STAGING_STUDY.COLUMN_NAME AS FIELD, 
  VW_USER_INFO.ID AS CRT_BY, 
  UNPIVOTED_STAGING_STUDY.DICTIONARY_ID AS DICTIONARY_ID, 
  UNPIVOTED_DATAMART_STUDY.DATAMART_VALUE != UNPIVOTED_STAGING_STUDY.STAGE_VALUE AS IS_NEW_VALUE 
FROM 
  DATAMART_STUDY UNPIVOT(
    DATAMART_VALUE FOR COLUMN_NAME IN (
      NAME, STUDY_FAMILY_ID, STUDY_RELEASE_ID, 
      STUDY_TYPE_ID, STUDY_CODE, SECURITYCODE, 
      RELEASE_DATE, YEAR, 
      TREND_FAMILY_ID, MINWAVE, MAXWAVE, 
      STARTFIELDDATE, ENDFIELDDATE, USEEXTERNALKEY, 
      ACTIVE, PARENT_STUDY_ID, DP_STUDYID,HIDE
    )
  ) AS UNPIVOTED_DATAMART_STUDY 
  JOIN STAGING_STUDY UNPIVOT(
    STAGE_VALUE FOR COLUMN_NAME IN (
      NAME, STUDY_FAMILY_ID, STUDY_RELEASE_ID, 
      STUDY_TYPE_ID, STUDY_CODE, SECURITYCODE, 
      RELEASE_DATE, YEAR, 
      TREND_FAMILY_ID, MINWAVE, MAXWAVE, 
      STARTFIELDDATE, ENDFIELDDATE, USEEXTERNALKEY, 
      ACTIVE, PARENT_STUDY_ID, DP_STUDYID, HIDE
    )
  ) AS UNPIVOTED_STAGING_STUDY ON UNPIVOTED_STAGING_STUDY.ID = UNPIVOTED_DATAMART_STUDY.ID 
  AND UNPIVOTED_STAGING_STUDY.COLUMN_NAME = UNPIVOTED_DATAMART_STUDY.COLUMN_NAME 
  JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_ACTION_TYPE" on UPPER(VW_ACTION_TYPE.NAME) = 'UPDATE'
  JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_USER_INFO" on VW_USER_INFO.FIRST_NAME = 'ETL_USER'
  
WHERE 
  IS_NEW_VALUE = TRUE;
  

create or replace view VW_STUDY_WEIGHT(
	STUDY_ID,
	WEIGHT_TYPE_ID,
	WEIGHT_EXTENSION_ID,
	MULTIPLIER,
	DIVISOR,
	CCP,
	PERSISTENT_ID,
	CRT_TS,
	CRT_BY,
	UPD_BY,
	UPD_TS
) as

select 
  STUDY_ID,
  VW_WEIGHT_TYPE.ID as WEIGHT_TYPE_ID,
  VW_WEIGHT_EXTENSION.ID as WEIGHT_EXTENSION_ID,
  MULTIPLIER,
  DIVISOR,
  CCP,
  KEYWORD as PERSISTENT_ID,
  CURRENT_TIMESTAMP AS CRT_TS, 
  VW_USER_INFO.ID as CRT_BY,
  NULL as UPD_BY,
  NULL as UPD_TS
  
from 
  "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."WEIGHT_STG" 
  join "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_WEIGHT_TYPE" on WEIGHT_STG.WEIGHT_TYPE = VW_WEIGHT_TYPE.WEIGHT_TYPE 
  join "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_WEIGHT_EXTENSION" on WEIGHT_STG.EXTENSION = VW_WEIGHT_EXTENSION.WEIGHT_EXTENSION
  join "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."STUDY_STG" on WEIGHT_STG.DP_STUDY_ID = STUDY_STG.DP_STUDY_ID
  join "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_USER_INFO" on VW_USER_INFO.FIRST_NAME = 'ETL_USER';
  
  
create or replace view VW_SUPRESSION_STG(
	DICTIONARY_ID,
	KEYWORD,
	DELIVERABLE_ID,
	ACTIVE,
	CRT_TS,
	CRT_BY,
	UPD_BY,
	UPD_TS
) as 

select 
  DICTIONARY_ID, 
  KEYWORD, 
  VW_DELIVERABLE.DELIVERABLE_ID as DELIVERABLE_ID, 
  TRUE, 
  current_timestamp(4) as CRT_TS, 
  VW_USER_INFO.ID as CRT_BY, 
  NULL as UPD_BY, 
  NULL as UPD_TS
from 
  "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."SUPPRESSION_STG" 
  join "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_USER_INFO" on VW_USER_INFO.FIRST_NAME = 'ETL_USER'
  join "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_DELIVERABLE" on VW_DELIVERABLE.DELIVERABLE = 'Both';
  
  
create or replace view VW_WEIGHT_EXTENSION(
	WEIGHT_EXTENSION,
	ACTIVE,
	CRT_TS,
	CRT_BY,
	UPD_BY,
	UPD_TS
) as

WITH NEW_WEIGHT_EXTENSION as (
  SELECT 
    EXTENSION 
  FROM 
    "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."WEIGHT_STG" QUALIFY ROW_NUMBER() OVER (
      PARTITION BY EXTENSION 
      ORDER BY 
        EXTENSION
    ) = 1 
  EXCEPT 
  SELECT 
    WEIGHT_EXTENSION 
  FROM 
    "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_WEIGHT_EXTENSION" QUALIFY ROW_NUMBER() OVER (
      PARTITION BY WEIGHT_EXTENSION 
      ORDER BY 
        WEIGHT_EXTENSION
    ) = 1

)

SELECT 
  EXTENSION as WEIGHT_EXTENSION, 
  TRUE as ACTIVE, 
  CURRENT_TIMESTAMP AS CRT_TS, 
  VW_USER_INFO.ID AS CRT_BY, 
  NULL AS UPD_BY, 
  NULL AS UPD_TS 
FROM 
  NEW_WEIGHT_EXTENSION
  JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_USER_INFO" ON VW_USER_INFO.FIRST_NAME = 'ETL_USER';
  
  
create or replace view VW_WEIGHT_TYPE(
	WEIGHT_TYPE,
	ACTIVE,
	CRT_TS,
	CRT_BY,
	UPD_BY,
	UPD_TS
) as 
WITH NEW_WEIGHT_TYPE AS (
  SELECT 
    WEIGHT_TYPE 
  FROM 
    "DEV_DATAMART_DB"."MDM_DICTIONARY_STAGE"."WEIGHT_STG" QUALIFY ROW_NUMBER() OVER (
      PARTITION BY WEIGHT_TYPE 
      ORDER BY 
        WEIGHT_TYPE
    ) = 1 
  EXCEPT 
  SELECT 
    WEIGHT_TYPE 
  FROM 
    "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_WEIGHT_TYPE" QUALIFY ROW_NUMBER() OVER (
      PARTITION BY WEIGHT_TYPE 
      ORDER BY 
        WEIGHT_TYPE
    ) = 1
) 
SELECT 
  WEIGHT_TYPE, 
  TRUE as ACTIVE, 
  CURRENT_TIMESTAMP AS CRT_TS, 
  VW_USER_INFO.ID AS CRT_BY, 
  NULL AS UPD_BY, 
  NULL AS UPD_TS 
FROM 
  NEW_WEIGHT_TYPE 
  JOIN "DEV_DATAMART_DB"."DEV_DICTIONARY"."VW_USER_INFO" ON VW_USER_INFO.FIRST_NAME = 'ETL_USER';
